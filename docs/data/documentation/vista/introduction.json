{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Views-User-Interface-made-simple","level":2,"type":"heading","text":"Views: User Interface made simple"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Views are at the heart of every SwiftUI application. They define the user interface and react to changes in the application’s state, providing a dynamic and responsive UI. In "},{"type":"strong","inlineContent":[{"type":"text","text":"VISTA"}]},{"type":"text","text":" architecture, Views are kept simple, minimal logic. They primarily focus on displaying information and interacting with the user. SwiftUI’s decalarative syntax empowers Views to respond to changes automatically reducing the manual effort required."}]},{"type":"codeListing","syntax":"swift","code":["struct ContentView: View {","    var body: some View {","        VStack {","            Text(\"Welcome to Vista Architecture\")","            Button(\"Click me\") {","                \/\/ Button action","            }","        }","    }","}"]},{"anchor":"Interactors-Empowering-Business-Logic","level":2,"type":"heading","text":"Interactors: Empowering Business Logic"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Interactors, also known as "},{"type":"strong","inlineContent":[{"type":"text","text":"services"}]},{"type":"text","text":",  contain the business logic of the application. They are responsible for performing comlex operations such as data manipulation, fetching data from repositories, and storing data. Interators are independant of the user interface and can be tested in isolation. This separation allows for better code organization and reusability. By encapsulating business logic within Interactors, you can ensure that your codebase remains focused and maintainable."}]},{"type":"codeListing","syntax":"swift","code":["protocol ContentInteractorProtocol {","    func incrementCount()","}","","class ContentInteractor: ContentInteractorProtocol {","    private let repository: ContentRepositoryProtocol","    ","    init(repository: ContentRepositoryProtocol) {","        self.repository = repository","    }","    ","    func incrementCount() {","        repository.incrementCount()","    }","}"]},{"anchor":"State-Managing-Application-State","level":2,"type":"heading","text":"State: Managing Application State"},{"type":"paragraph","inlineContent":[{"type":"text","text":"State is a crucial component of "},{"type":"strong","inlineContent":[{"type":"text","text":"VISTA"}]},{"type":"text","text":" architecture. It represents the "},{"type":"strong","inlineContent":[{"type":"text","text":"ViewModels"}]},{"type":"text","text":" that hold the state of the Views. Stateful ViewModels interact with Interactors to perform operations and update the state based on the results. SwiftUI provides built-in property wrappers like "},{"type":"codeVoice","code":"@State"},{"type":"text","text":", "},{"type":"codeVoice","code":"@ObservableObject"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@EnvironmentObject"},{"type":"text","text":" to manage state changes effectively. By embracing reactive programming with SwiftUI, you can create responsive applications that automatically update the UI when the state changes."}]},{"type":"codeListing","syntax":"swift","code":["class ContentViewModel: ObservableObject {","    @Published var count = 0","    private let interactor = ContentInteractor()","","    func incrementCount() {","        count = interactor.incrementCount(currentCount: count)","    }","}"]},{"anchor":"Transformers-Seamless-Data-Transformation","level":2,"type":"heading","text":"Transformers: Seamless Data Transformation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Transformers, also known as "},{"type":"strong","inlineContent":[{"type":"text","text":"Mappers"}]},{"type":"text","text":", play a vital role in maintaining clean separation between different layers of your application. They handle the mapping and transformation of data between entities, view models, and other data models. By using Transformers, you ensure that each layer of your application understands and operates on the appropriate data representation. This improves code readability, testability and maintainability."}]},{"type":"codeListing","syntax":"swift","code":["struct ContentTransformer {","    static func transform(count: Int) -> String {","        return \"Count: \\(count)\"","    }","}"]},{"anchor":"Agents-Efficient-Workers","level":2,"type":"heading","text":"Agents: Efficient Workers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Agents represent small, focused "},{"type":"strong","inlineContent":[{"type":"text","text":"workers"}]},{"type":"text","text":" that perform repetitive tasks in your application. They help abstract away common operations, making your codebase cleaner and more maintainable. Agents can handle tasks lsuc as image downloading, data caching, or background synchronization. By utilizing Agents, you keep your code modular and prevent cluttering with repetitive code snippets."}]},{"type":"codeListing","syntax":"swift","code":["class ImageDownloader {","    func downloadImage(from url: URL) {","        \/\/ Perform image downloading logic here","    }","}"]},{"anchor":"Benefits-of-Vista-Architecture","level":2,"type":"heading","text":"Benefits of Vista Architecture"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Scalability:"}]},{"type":"text","text":" VISTA Architecture promotes separation of concerns, allowing the application to scale as it grows in complexity."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Testability:"}]},{"type":"text","text":" Each component can be tested independently, enabling thorough unit testing and ensuring the reliability of the codebase"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Maintainability:"}]},{"type":"text","text":" The clear separation of responsibility and the modular structure of the architecture make it easier to navigate, understand, and maintain the codebase over time."}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/vista\/introduction"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/com.Vikram.VISTA\/documentation\/VISTA\/Introduction","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Welcome to the world of VISTA Architecture! VISTA is a new approach to building SwiftUI applications, designed to enhance scalability, testability and maintainability. The name VISTA stands for Views, Interactors, State, Transformers and Agents, each representing a key component of the architecture. In this Introduction, we will delve into each component, explore their roles and see how they interact to form a cohesive, robust architecture."}],"kind":"article","metadata":{"title":"Introducing VISTA: A New Architecture for SwiftUI","roleHeading":"Article","role":"article"},"hierarchy":{"paths":[["doc:\/\/com.Vikram.VISTA\/tutorials\/Vista","doc:\/\/com.Vikram.VISTA\/tutorials\/Vista\/$volume","doc:\/\/com.Vikram.VISTA\/tutorials\/Vista\/Introduction"]]},"references":{"doc://com.Vikram.VISTA/tutorials/Vista":{"role":"overview","title":"Introducing VISTA","abstract":[{"type":"text","text":"Welcome to the world of VISTA Architecture!"}],"identifier":"doc:\/\/com.Vikram.VISTA\/tutorials\/Vista","kind":"overview","type":"topic","url":"\/tutorials\/vista"},"doc://com.Vikram.VISTA/tutorials/Vista/Introduction":{"role":"article","title":"Introduction","abstract":[],"identifier":"doc:\/\/com.Vikram.VISTA\/tutorials\/Vista\/Introduction","kind":"article","type":"topic","url":"\/tutorials\/vista\/introduction"},"doc://com.Vikram.VISTA/tutorials/Vista/$volume":{"role":"article","title":"$volume","abstract":[],"identifier":"doc:\/\/com.Vikram.VISTA\/tutorials\/Vista\/$volume","kind":"article","type":"topic","url":"\/tutorials\/vista\/$volume"}}}